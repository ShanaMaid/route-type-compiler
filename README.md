# Route Type Compiler

> Compiler d.ts for route file on server side, then use the d.ts for you request on client side!

> It's pretty useful to get type protect in restful http communication

## Usage

### 1.In the server side, we have a route like this:

```
import {Controller, HttpMethod, route} from 'koa-decorator';
import ITodo from '@server/declaration/Todo';
import {Context} from 'koa';

@route('/demo')
export default class DemoCtrl extends Controller {

  @route('/', HttpMethod.GET)
  async alive(): Promise<{text: string}> {
    return {text: 'hello world'};
  }

  /**
   * 使用原生 koa 返回数据
   */
  @route('/koa', HttpMethod.GET)
  async koa(ctx: Context) {
    ctx.body = '123';
  }

  @route('/error/path/somepath', HttpMethod.GET, other)
  async error(): Promise<ITodo[]> {
    throw {
      code: 12345,
      msg: '出错了',
      data: {
        userId: 'Tom',
      },
    };
  }

  @route('/koa', HttpMethod.POST)
  async koaPost(ctx: Context) {
    const data = ctx.request.body;
    
    return {
      koa: 'fun in koa',
      data,
    }
  }
}
```

### 2. Compile the d.ts for the route file dependent on path and method type

*route.d.ts*
```
/*
* Autogenerated by Route Type Compiler (1.0.0)
*
* DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
*/

import ApiDemo from './api/demo';
import Demo from './demo';

declare module 'test' {
  const apiDemo: ApiDemo;
  const demo: Demo;
  export interface IGetRoute {
    'api/demo/': typeof apiDemo.alive,
    'api/demo/koa': typeof apiDemo.koa,
    'api/demo/error/path/somepath': typeof apiDemo.error,
    '/demo/': typeof demo.alive,
    '/demo/koa': typeof demo.koa,
    '/demo/error/path/somepath': typeof demo.error
  }
  export interface IPostRoute {
    'api/demo/koa': typeof apiDemo.koaPost,
    '/demo/koa': typeof demo.koaPost
  }
}
```

### 3.Then test module have all the route file type, use test module on client side.

